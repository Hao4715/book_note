# 第2章 编译和链接
## 2.1 被隐藏的过程
程序从源码到可执行文件经过四步：预处理（prepressing）、编译（compilation）、汇编（assembly）和链接（linking）。
### 2.1.1 预编译、
预编译过程相当于`gcc -E hello.c -o hello.i` -E 表示只进行预编译。
与编译过程主要处理源代码文件中以“#”开始的预编译指令。比如“#include”、“#define”、删除注释、添加行号和文件名标识等。
### 2.1.2 编译
编译过程就是把预处理完的文件进行一系列**词法分析**、**语法分析**、**语义分析**及**优化**后生成相应的汇编代码文件。**编译过程是整个程序构建的核心部分。**上述编译过程相当于`gcc -S hello.i -o hello.s`。

现代编译器将预处理和编译两个步骤合并成一个步骤。使用 `gcc -S hello.c -o hello.s`即可得到汇编输出文件hello.s。

所以实际上gcc命令指示后台程序的包装，它会根据不同的参数要求去调用**预编译编译程序cc1**、**汇编器as**、**连接器ld**。
### 2.1.3 汇编
汇编器是将汇编代码转变成机器可以执行的指令。汇编器可以调用汇编器as来完成 `as hello.s -o hello.o` 或 `gcc -c hello.s -o hello.o`。或者使用gcc从C源码文件直接开始，经过预编译、编译和汇编直接输出**目标文件**`gcc -c hello.c -o hello.o`。
### 2.1.4 链接
## 2.2 编译器做了什么
编译过程一般可分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
### 2.2.1 词法分析
首先源码文件被输入到**扫描器**，扫描器只是简单的进行词法分析，运用一种**有限状态机**的算法将源码的字符序列分割成一系列**记号**。
### 2.2.2 语法分析
**语法分析器**将对由扫描器产生的记号进行语法分析，从而生成**语法树**。采用**上下文无关语法**，生成的语法树就是以**表达式**为节点的树。
### 2.2.3 语义分析
**语义分析器**接下来进行语义分析。语义分析仅完成对表达式的语法层面的分析，并不关心语句是否真的有意义，例如指针乘法运算是无意义的但语法上是合法的。编译器能分析的语义是**静态语义**，也就是编译期可以确定地语义，例如声明和类型的匹配，类型转换。**动态语义**就是只有在运行期才确定的语义，例如0作为除数是一个运行期语义错误。

语义分析后，整个语法树都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。
### 2.2.4 中间语言生成
**源码级优化器**会在源码层面进行优化，例如对在编译器可确定结果的表达式进行计算以及替换。生成中间代码（任然与机器和目标环境无关的代码）。中间代码是的编译器可被分为前端和后端。编译器前端负责产生机器无关的中间代码，后端将中间代码转换成目标机器代码。
### 2.2.5 目标代码生成与优化
编译器后端主要包括**代码生成器**（将中间代码转换成目标机器代码）和**目标代码优化器**（对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余指令等）。